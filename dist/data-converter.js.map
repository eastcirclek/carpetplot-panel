{"version":3,"sources":["../src/data-converter.js"],"names":["moment","aggregate","getFragment","createConverter","aggregateType","fragmentType","prepareData","from","to","fragment","data","fromUtc","utc","startOf","toUtc","add","timeUtc","isBefore","nextTime","valueOf","timestamp","values","groupData","dataList","container","targets","_","map","forEach","target","datapoints","filter","value","bucketTimestamp","getBucketTimestamp","push","aggregateData","aggregateFunc","result","createBucket","buckets","bucket","size","firstTimestamp","first","Object","forOwn","arr","length","normalizeData","obj","sum","mapValues","rankData","sortedValues","sortBy","indexOf","convertData","processingMode","agg","eq","allValues","flatten","stats","min","max"],"mappings":"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","file":"data-converter.js","sourcesContent":["import moment from 'moment';\n\nimport { aggregate } from './aggregates';\nimport { getFragment } from './fragments';\n\nconst createConverter = (aggregateType, fragmentType) => {\n\n  const prepareData = (from, to, fragment) => {\n    const data = {};\n    const fromUtc = moment.utc(from).startOf('day');\n    const toUtc = moment.utc(to).startOf('day').add(1, 'day');\n    // timeUtc = timeUtc.add(1, 'day')\n    for (let timeUtc = moment.utc(fromUtc); timeUtc.isBefore(toUtc); timeUtc = fragment.nextTime(timeUtc)) {\n      data[timeUtc.valueOf()] = {\n        // time: timeUtc.clone(),\n        timestamp: timeUtc.valueOf(),\n        values: {}\n      };\n    }\n    return {\n      data,\n      from: fromUtc,\n      to: toUtc\n    };\n  };\n\n  const groupData = (from, to, fragment, dataList) => {\n    const container = prepareData(from, to, fragment);\n    const targets = _.map(dataList, 'target');\n    container.targets = targets;\n\n    dataList.forEach(({ target, datapoints }) => {\n      datapoints\n        .filter(([value]) => value !== null)\n        .forEach(([value, timestamp]) => {\n          const bucketTimestamp = fragment.getBucketTimestamp(timestamp);\n          if (!(bucketTimestamp in container.data)) { return; }\n          if (!(target in container.data[bucketTimestamp].values)) {\n            container.data[bucketTimestamp].values[target] = [];\n          }\n          container.data[bucketTimestamp].values[target].push(value);\n        });\n    });\n\n    return container;\n  };\n\n  const aggregateData = (from, to, fragment, container) => {\n    const data = container.data;\n    const aggregateFunc = aggregate(aggregateType);\n    const result = [];\n\n    const createBucket = (timestamp) => ({\n      timestamp,\n      buckets: {}\n    });\n\n    // let bucket = createBucket(moment(from).startOf('day'));\n    let bucket;\n    if (data && _.size(data) > 0) {\n      const firstTimestamp = _.first(_.values(data))['timestamp'];\n      bucket = createBucket(firstTimestamp);\n    }\n\n    Object.values(data).forEach(({ timestamp, values }) => {\n      if (timestamp < bucket.timestamp) { return; }\n\n      const bucketTimestamp = fragment.getBucketTimestamp(timestamp);\n      if (bucket.timestamp != bucketTimestamp) {\n        result.push({ ...bucket });\n        bucket = createBucket(bucketTimestamp);\n      }\n\n      _.forOwn(values, function(arr, target) {\n        const value = arr.length > 0\n          ? aggregateFunc(arr)\n          : null;\n\n        bucket.buckets[target] = value;\n      });\n    });\n\n    result.push({ ...bucket });\n\n    return result;\n  };\n\n  const normalizeData = (data) => {\n    return _.map(data, function (obj) {\n      const values = _.values(obj.buckets);\n      const sum = _.sum(values);\n      // const sortedValues = _.sortBy(values);\n\n      obj.buckets = _.mapValues(obj.buckets, value => value/sum\n        // function(value) {\n        //   const rank = values.length - _.sortedIndexOf(sortedValues, value);\n        //   if (rank < 5) {\n        //     return value/sum;\n        //   } else {\n        //     return 0;\n        //   }\n        // }\n      );\n\n      return obj;\n    });\n  };\n\n  const rankData = (data) => {\n    return _.map(data, function (obj) {\n\n\n      const sortedValues = _.sortBy(_.values(obj.buckets));\n\n      obj.buckets = _.mapValues(obj.buckets, function(value) {\n        return _.indexOf(sortedValues, value);\n      });\n\n      return obj;\n    });\n  };\n\n  const convertData = (from, to, dataList, processingMode) => {\n    const fragment = getFragment(fragmentType);\n    const container = groupData(from, to, fragment, dataList);\n    let agg = aggregateData(from, to, fragment, container);\n    if (_.eq(processingMode, 'normalize')) { agg = normalizeData(agg); }\n    else if (_.eq(processingMode, 'rank')) {agg = rankData(agg);}\n    const allValues = _.flatten(_.map(agg, obj => _.values(obj.buckets)));\n    const data = {\n      data: agg,\n      stats: {\n        min: _.min(allValues),\n        max: _.max(allValues)\n      }\n    };\n\n    return {\n      ...container,\n      ...data\n    };\n  };\n\n  return {\n    convertData\n  };\n};\n\nexport default createConverter;"]}